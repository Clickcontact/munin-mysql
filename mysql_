#!/usr/bin/perl

#   Munin magick markers:
#%# family=contrib
#%# capabilities=suggest


use warnings;
use strict;
use utf8;

# TODO
#
# - Parse transaction section of innodb status. This section gets
#   truncated when many transactions are running. Doesn't that make it
#   valueless for munin-purposes?
#
# - Status from SHOW PROCESSLIST. How useful is this?
#
# - Document graph interpretation
#
# - Measure slave lag by using maatkit's mk-heartbeat if present
#
# - The Cacti 'Query Cache Memory Usage' graph includes
#   Qcache_total_blocks and Qcache_free_blocks in addition to
#   query_cache_size Qcache_free_memory. Can't see how these fit in
#   the same graph since they have different scale (blocks vs
#   bytes). Make a separate graph and include Qcache_lowmem_prunes?
#
# - Add vlabel on graphs. 
#
# - Add documentation on minimum privileges needed (USAGE or SUPER
#   depending on which tables are accessed)

use Cache::SharedMemoryCache;
use DBI;
use File::Basename;
use Math::BigInt; # Used to append "=> lib 'GMP'" here, but GMP caused
                  # segfault on some occasions. Removed as I don't
                  # think the tiny performance boost is worth the
                  # debugging effort.



#---------------------------------------------------------------------
#  C O N F I G
#---------------------------------------------------------------------

my %config = (
    'dsn'        => $ENV{'mysqlconnection'} || 'DBI:mysql:mysql',
    'user'       => $ENV{'mysqluser'}       || 'root',
    'password'   => $ENV{'mysqlpassword'}   || '',
    'check'      => $ENV{'mysqlcheck'}      || 'vars,innodb,master,slave',
);
$config{check} = {map {$_ => 1} split(/,/, $config{check})};


#---------------------------------------------------------------------
#  C A C H E
#---------------------------------------------------------------------

my %cache_options = ( 
    'namespace'          => 'munin_mysql',
    'default_expires_in' => 60,
);

my $shared_memory_cache = Cache::SharedMemoryCache->new(\%cache_options)
    or die("Couldn't instantiate SharedMemoryCache");


#---------------------------------------------------------------------
#  G R A P H   D E F I N I T I O N S
#---------------------------------------------------------------------

# These are defaults to save typing in the graph definitions
my %defaults = (
    global_attrs => {
        args   => '--base 1000',
    },
    data_source_attrs => {
        min   => '0',
        type  => 'DERIVE',
        draw  => 'AREASTACK',
    },
);

# %graphs contains the graph definitions, it is indexed on the graph
# name. The information stored for each graph is used for both showing
# data source values and for printing the graph configuration. Each
# graph follows the followingformat:
#
# $graph{NAME} => {
#     config => {
#         # The global attributes for this graph
#         global_attrs => {} 
#         # Attributes common to all data sources in this graph
#         data_source_attrs => {}
#     },
#     data_sources => [
#         # NAME - The name of the data source (e.g. variable names 
#         #        from SHOW STATUS)
#         # DATA_SOURCE_ATTRS - key-value pairs with data source 
#         #                     attributes
#         {name => 'NAME', (DATA_SOURCE_ATTRS)},
#         {...},
#     ],
my %graphs = ();

#---------------------------------------------------------------------

$graphs{bin_relay_log} = {
    config => {
        global_attrs => {
            title  => 'Binary/Relay Logs',
            vlabel => 'FIX',
        },
        data_source_attrs => {
            draw  => 'LINE1',
        },
    },
    data_sources => [
        {name => 'Binlog_cache_disk_use', label => 'Binlog Cache Disk Use'},
        {name => 'Binlog_cache_use',      label => 'Binlog Cache Use'},
        {name => 'ma_binlog_size',        label => 'Binary Log Space'},
        {name => 'relay_log_space',       label => 'Relay Log Space'},
    ],
};

#---------------------------------------------------------------------

$graphs{connections} = {
    config => {
        global_attrs => {
            title  => 'Connections',
            vlabel => 'connections / ${graph_period}',
        },
        data_source_attrs => {
            draw  => 'LINE1',
        },
    },
    data_sources => [
        {name => 'max_connections',      label  => 'Max connections', 
                                         type   => 'GAUGE',
                                         draw   => 'AREA',
                                         colour => 'cdcfc4'},
        {name => 'Max_used_connections', label  => 'Max used',
                                         type   => 'GAUGE',
                                         draw   => 'AREA',
                                         colour => 'ffd660'},
        {name => 'Aborted_clients',      label => 'Aborted clients'},
        {name => 'Aborted_connects',     label => 'Aborted connects'},
        {name => 'Threads_connected',    label => 'Threads connected',
                                         type  => 'GAUGE'},
        {name => 'Connections',          label => 'New connections'},
    ],
};

#---------------------------------------------------------------------

$graphs{files_tables} = {
    config => {
        global_attrs => {
            title  => 'Files and tables',
            vlabel => 'tables',
        },
        data_source_attrs => {
            type  => 'GAUGE',
            draw  => 'LINE1',
        },
    },
    data_sources => [
        {name => 'table_open_cache', label  => 'Table cache',
                                     draw   => 'AREA',
                                     colour => 'cdcfc4'},
        {name => 'Open_files',       label => 'Open files'},
        {name => 'Open_tables',      label => 'Open tables'},
        {name => 'Opened_tables',    label => 'Opened tables',
                                     type  => 'GAUGE'},
    ],
};

#---------------------------------------------------------------------

$graphs{innodb_bpool} = {
    config => {
        global_attrs => {
            title  => 'InnoDB Buffer Pool',
            vlabel => 'pages',
            base   => '1024',
        },
        data_source_attrs => {
            draw => 'LINE2',
            type => 'GAUGE',
        },
    },
    data_sources => [
        {name => 'ib_bpool_size',     label  => 'Buffer pool size',
                                      draw   => 'AREA',
                                      colour => 'ffd660'},
        {name => 'ib_bpool_free',     label => 'Free pages'},
        {name => 'ib_bpool_dbpages',  label  => 'Database pages',
                                      draw   => 'AREA',
                                      colour => 'cdcfc4'},
        {name => 'ib_bpool_modpages', label => 'Modified pages'},
    ],
};

#---------------------------------------------------------------------

$graphs{innodb_bpool_act} = {
    config => {
        global_attrs => {
            title  => 'InnoDB Buffer Pool Activity',
            vlabel => 'actions / ${graph_period}',
            total  => 'Total',
        },
        data_source_attrs => {
            draw => 'LINE2',
        },
    },
    data_sources => [
        {name => 'ib_bpool_read',    label => 'Pages read'},
        {name => 'ib_bpool_created', label => 'Pages created'},
        {name => 'ib_bpool_written', label => 'Pages written'},
    ],
};

#---------------------------------------------------------------------

$graphs{innodb_insert_buf} = {
    config => {
        global_attrs => {
            title  => 'InnoDB Insert Buffer',
            vlabel => 'FIX',
        },
        data_source_attrs => {
            draw => 'LINE1',
        },
    },
    data_sources => [
        {name => 'ib_ibuf_inserts',    label => 'Inserts'},
        {name => 'ib_ibuf_merged_rec', label => 'Merged Records'},
        {name => 'ib_ibuf_merges',     label => 'Merges'},
    ],
};    
  
#---------------------------------------------------------------------

$graphs{innodb_io} = {
    config => {
        global_attrs => {
            title  => 'InnoDB IO',
            vlabel => 'FIX',
        },
        data_source_attrs => {
            draw => 'LINE1',
        },
    },
    data_sources => [
        {name => 'ib_io_read',  label => 'File reads'},
        {name => 'ib_io_write', label => 'File writes'},
        {name => 'ib_io_log',   label => 'Log writes'},
        {name => 'ib_io_fsync', label => 'File syncs'},
    ],
};

#---------------------------------------------------------------------

$graphs{innodb_io_pend} = {
    config => {
        global_attrs => {
            title  => 'InnoDB IO Pending',
            vlabel => 'FIX',
        },
        data_source_attrs => {
            draw => 'LINE1',
        },
    },
    data_sources => [
        {name => 'ib_iop_log',         label => 'AIO Log'},
        {name => 'ib_iop_sync',        label => 'AIO Sync'},
        {name => 'ib_iop_flush_bpool', label => 'Buf Pool Flush'},
        {name => 'ib_iop_flush_log',   label => 'Log Flushes'},
        {name => 'ib_iop_ibuf_aio',    label => 'Insert Buf AIO Read'},
        {name => 'ib_iop_aioread',     label => 'Normal AIO Reads'},
        {name => 'ib_iop_aiowrite',    label => 'Normal AIO Writes'},
    ],
};

#---------------------------------------------------------------------

$graphs{innodb_log} = {
    config => {
        global_attrs => {
            title  => 'InnoDB Log',
            vlabel => 'FIX',
        },
        data_source_attrs => {
            draw => 'LINE1',
        },
    },
    data_sources => [
        {name => 'innodb_log_buffer_size', label  => 'Buffer Size',
                                           type   => 'GAUGE',
                                           draw   => 'AREA',
                                           colour => 'fafd9e'},
        {name => 'ib_log_flush',           label => 'KB Flushed'},
        {name => 'ib_log_written',         label => 'KB Written'},
    ],
};

#---------------------------------------------------------------------

$graphs{innodb_rows} = {
    config => {
        global_attrs => {
            title  => 'InnoDB Row Operations',
            vlabel => 'operations / ${graph_period}',
            total  => 'Total',
        },
        data_source_attrs => {},
    },
    data_sources => [
        {name => 'Innodb_rows_deleted',  label => 'Deletes'},
        {name => 'Innodb_rows_inserted', label => 'Inserts'},
        {name => 'Innodb_rows_read',     label => 'Reads'},
        {name => 'Innodb_rows_updated',  label => 'Updates'},
    ],
};

#---------------------------------------------------------------------

$graphs{innodb_semaphores} = {
    config => {
        global_attrs => {
            title  => 'InnoDB Semaphores',
            vlabel => 'FIX',
        },
        data_source_attrs => {
            draw  => 'LINE1',
        },
    },
    data_sources => [
        {name => 'ib_spin_rounds', label => 'Spin Rounds'},
        {name => 'ib_spin_waits',  label => 'Spin Waits'},
        {name => 'ib_os_waits',    label => 'OS Waits'},
    ],
};

#---------------------------------------------------------------------

$graphs{innodb_tnx} = {
    config => {
        global_attrs => {
            title  => 'InnoDB Transactions',
            vlabel => 'FIX',
        },
        data_source_attrs => {
            draw  => 'LINE1',
        },
    },
    data_sources => [
        {name => 'ib_tnx', label => 'Transactions created'},
    ],
};

#---------------------------------------------------------------------

$graphs{myisam_indexes} = {
    config => {
        global_attrs => {
            title  => 'MyISAM Indexes',
            vlabel => 'Requests per ${graph_period}',
        },
        data_source_attrs => {
            draw  => 'LINE2',
        },
    },
    data_sources => [
        {name => 'Key_read_requests',  label => 'Key read requests'},
        {name => 'Key_reads',          label => 'Key reads'}, 
        {name => 'Key_write_requests', label => 'Key write requests'},
        {name => 'Key_writes',         label => 'Key writes'},
   ],
};
  
#---------------------------------------------------------------------

$graphs{network_traffic} = {
    config => {
        global_attrs => {
            title  => 'Network Traffic',
            args   => '--base 1024',
            vlabel => 'bytes received (-) / sent (+) per ${graph_period}',
        },
        data_source_attrs => {
            draw  => 'LINE2',
        },
    },
    data_sources => [
        {name => 'Bytes_received', label => 'Bytes transfered',
                                   graph => 'no'},
        {name => 'Bytes_sent',     label    => 'Bytes transfered',
                                   negative => 'Bytes_received'},
    ],
};
  
#---------------------------------------------------------------------

$graphs{queries} = {
    config => {
        global_attrs => {
            title  => 'Command Counters',
            vlabel => 'commands / ${graph_period}',
            total  => 'Questions',
        },
        data_source_attrs => {},
    },
    data_sources => [
        {name => 'Com_delete',         label => 'Delete'},
        {name => 'Com_insert',         label => 'Insert'},
        {name => 'Com_insert_select',  label => 'Insert select'},
        {name => 'Com_load',           label => 'Load Data'},
        {name => 'Com_replace',        label => 'Replace'},
        {name => 'Com_replace_select', label => 'Replace select'},
        {name => 'Com_select',         label => 'Select'},
        {name => 'Com_update',         label => 'Update'},
        {name => 'Com_update_multi',   label => 'Update multi'},
    ],
};

#---------------------------------------------------------------------

$graphs{qcache} = {
    config => {
        global_attrs => {
            title  => 'Query Cache',
            vlabel => 'FIX',
        },
        data_source_attrs => {
             draw => 'LINE1',
        },
    },
    data_sources => [
        {name => 'Qcache_queries_in_cache', label => 'Queries in cache'},
        {name => 'Qcache_hits',             label => 'Cache hits'},
        {name => 'Qcache_inserts',          label => 'Inserts'},
        {name => 'Qcache_not_cached',       label => 'Not cached'},
        {name => 'Qcache_lowmem_prunes',    label => 'Low-memory prunes'},
    ],
};

#---------------------------------------------------------------------

$graphs{qcache_mem} = {
    config => {
        global_attrs => {
            title  => 'Query Cache Memory',
            vlabel => 'FIX',
        },
        data_source_attrs => {
            draw => 'AREA',
            type => 'GAUGE',
        },
    },
    data_sources => [
        {name => 'query_cache_size',    label => 'Cache size'},
        {name => 'Qcache_free_memory',  label => 'Free mem'},
    ],
};

#---------------------------------------------------------------------

$graphs{replication} = {
    config => {
        global_attrs => {
            title  => 'Replication',
            vlabel => 'FIX',
        },
        data_source_attrs => {
            draw => 'LINE1',
        },
    },
    data_sources => [
        {name => 'slave_running',              label => 'Slave Running',
                                               type  => 'GAUGE',
                                               draw  => 'AREA'},
        {name => 'slave_stopped',              label => 'Slave Stopped',
                                               type  => 'GAUGE',
                                               draw  => 'AREA'},
        {name => 'Slave_retried_transactions', label => 'Retried Transactions'},
        {name => 'Slave_open_temp_tables',     label => 'Open Temp Tables'},
        {name => 'seconds_behind_master',      label => 'Secs Behind Master', 
                                               type  => 'GAUGE'},
    ],
};

#---------------------------------------------------------------------

$graphs{select_types} = {
    config => {
        global_attrs => {
            title  => 'Select types',
            vlabel => 'commands / ${graph_period}',
            total  => 'Total',
        },
        data_source_attrs => {},
    },
    data_sources => [
        {name => 'Select_full_join',       label => 'Full join'},
        {name => 'Select_full_range_join', label => 'Full range'},
        {name => 'Select_range',           label => 'Range'},
        {name => 'Select_range_check',     label => 'Range check'},
        {name => 'Select_scan',            label => 'Scan'},
    ],
};

#---------------------------------------------------------------------

$graphs{slow} = {
    config => {
        global_attrs => {
            title  => 'Slow Queries',
            vlabel => 'slow queries / ${graph_period}',
        },
        data_source_attrs => {
            draw  => 'LINE2',
        },
    },
    data_sources => [
        {name => 'Slow_queries', label => 'Slow queries'},
    ],
};

#---------------------------------------------------------------------

$graphs{sorts} = {
    config => {
        global_attrs => {
            title  => 'Sorts',
            vlabel => 'sorts / ${graph_period}',
        },
        data_source_attrs => {
            draw  => 'LINE2',
        },
    },
    data_sources => [
        {name => 'Sort_rows',         label => 'Rows sorted'},
        {name => 'Sort_range',        label => 'Range'},
        {name => 'Sort_merge_passes', label => 'Merge passes'},
        {name => 'Sort_scan',         label => 'Scan'},
    ],
};

#---------------------------------------------------------------------

$graphs{table_locks} = {
    config => {
        global_attrs => {
            title  => 'Table locks',
            vlabel => 'locks / ${graph_period}',
        },
        data_source_attrs => {
            draw  => 'LINE2',
        },
    },
    data_sources => [
        {name => 'Table_locks_immediate', label => 'Table locks immed'},
        {name => 'Table_locks_waited',    label => 'Table locks waited'},
    ],
};

#---------------------------------------------------------------------

$graphs{tmp_tables} = {
    config => {
        global_attrs => {
            title  => 'Temporary objects',
            vlabel => 'objects / ${graph_period}',
        },
        data_source_attrs => {
            draw  => 'LINE2',
        },
    },
    data_sources => [
        {name => 'Created_tmp_disk_tables', label => 'Temp disk tables'},
        {name => 'Created_tmp_tables',      label => 'Temp tables'},
        {name => 'Created_tmp_files',       label => 'Temp files'},
    ],
};


#---------------------------------------------------------------------
#  M A I N
#---------------------------------------------------------------------


#
# Global variable holding the data collected from mysql.
#
# $data = {
#    status    => {}, # SHOW GLOBAL STATUS
#    variables => {}, # SHOW GLOBAL VARIABLES
#    innodb    => {}, # SHOW ENGINE INNODB STATUS
# };
my $data;


sub main {
    my $graph = $graphs{substr(basename($0), length('mysql_'))};
    my $command = $ARGV[0] || 'show';

    die 'Unknown graph ' . ($graph ? $graph : '')
        if !$graph && $command ne 'suggest';
    
    my %command_map = (
        'config'  => \&config,
        'show'    => \&show,
        'suggest' => \&suggest,
    );
    
    die "Unknown command: $command" 
        unless exists $command_map{$command};
    
    return $command_map{$command}->($graph);
}


#---------------------------------------------------------------------
#  C O M M A N D   H A N D L E R S
#---------------------------------------------------------------------


sub show {
    my $graph = shift;

    update_data();

    for my $ds (@{$graph->{data_sources}}) {
        printf "%s.value %s\n", 
            clean_fieldname($ds->{name}), $data->{$ds->{name}};
    }
}


sub suggest {
    local $_;
    print "mysql_$_\n" for (sort keys(%graphs));
}


sub config {
    my $graph = shift;

    my %conf = (%{$defaults{global_attrs}}, %{$graph->{config}{global_attrs}});
    while (my ($k, $v) = each %conf) {
        print "graph_$k $v\n";
    }
    print "graph_category mysql2\n\n";

    my $i = 0;
    for my $ds (@{$graph->{data_sources}}) {
        my %ds_spec = (
            %{$defaults{data_source_attrs}},
            %{$graph->{config}{data_source_attrs}},
            %$ds,
        );
        while (my ($k, $v) = each %ds_spec) {
            # 'name' is only used internally in this script, not
            # understood by munin.
            next if ($k eq 'name');

            # AREASTACK is part of munin as of version 1.3.3 (not
            # released yet). Until then ...
            if ($k eq 'draw' && $v eq 'AREASTACK') {
                printf("%s.%s %s\n", 
                       clean_fieldname($ds->{name}), $k, ($i ? 'STACK' : 'AREA'));
            }
            else {
                printf("%s.%s %s\n", clean_fieldname($ds->{name}), $k, $v);
            }
            $i++;
        }
    }
}


#---------------------------------------------------------------------
#  U T I L I T Y   S U B S
#---------------------------------------------------------------------


sub update_data {
    $data = $shared_memory_cache->get('data');
    return if $data;

    #warn "Need to update cache";

    $data = {};

    my $dbh = DBI->connect($config{dsn}, $config{user}, $config{password},
                           {'RaiseError' => 1, FetchHashKeyName => 'NAME_lc'});

    # Set up defaults in case the server is not a slave
    $data->{relay_log_space} = 0;
    $data->{slave_running}   = 0;
    $data->{slave_stopped}   = 0;
    
    # Set up defaults in case binlog is not enabled
    $data->{ma_binlog_size} = 0;
    
    update_variables($data, $dbh)   if $config{check}{vars};
    update_innodb($data, $dbh)      if $config{check}{innodb};
    update_master($data, $dbh)      if $config{check}{master};
    update_slave($data, $dbh)       if $config{check}{slave};

    $shared_memory_cache->set('data', $data);
}


sub update_variables {
    my ($data, $dbh) = @_;
    my @queries = (
        'SHOW GLOBAL STATUS',
        'SHOW GLOBAL VARIABLES',
    );

    my %variable_name_map = (
        table_cache => 'table_open_cache', # table_open_cache was
                                           # previously known as
                                           # table_cache in MySQL
                                           # 5.1.2 and earlier.
    );

    for my $query (@queries) {
        $data->{$query} = {};

        my $sth = $dbh->prepare($query);
        $sth->execute();
        while (my $row = $sth->fetch) {
            my $var = $variable_name_map{$row->[0]} || $row->[0];
            $data->{$var} = $row->[1];
        }
        $sth->finish();
    }
}


sub update_innodb {
    my ($data, $dbh) = @_;

    my $sth = $dbh->prepare('SHOW /*!50000 ENGINE*/ INNODB STATUS');
    $sth->execute();
    my $row = $sth->fetchrow_hashref();
    my $status = $row->{'status'};
    $sth->finish();

    parse_innodb_status($status);
}


sub update_master {
    my ($data, $dbh) = @_;

    my $sth = $dbh->prepare('SHOW MASTER LOGS');
    eval {
        $sth->execute();
    };
    if ($@) {
        # SHOW MASTER LOGS failed becuase binlog is not enabled
        return if $@ =~ /You are not using binary logging/;
        die $@;
    }
        
    while (my $row = $sth->fetch) {
        $data->{ma_binlog_size} += $row->[1];
    }
    
    $sth->finish();
}


sub update_slave {
    my ($data, $dbh) = @_;

    my $sth = $dbh->prepare('SHOW SLAVE STATUS');
    $sth->execute();
    my $row = $sth->fetchrow_hashref();
    return unless $row;
    while (my ($k, $v) = each %$row) {
        $data->{$k} = $v;
    }
    $sth->finish();

    # undef when slave is stopped, or when MySQL fails to calculate
    # the lag (which happens depresingly often). (mk-heartbeat fixes
    # this problem.)
    $data->{seconds_behind_master} ||= 0;

    # Scale slave_running and slave_stopped relative to the slave lag.
    $data->{slave_running} = ($data->{slave_sql_running} eq 'Yes')
            ? $data->{seconds_behind_master} : 0;
    $data->{slave_stopped} = ($data->{slave_sql_running} eq 'Yes')
            ? 0 : $data->{seconds_behind_master};


}

#
# Can't use variable names longer than 19 characters:
# http://munin.projects.linpro.no/wiki/notes_on_datasource_names
#
sub clean_fieldname {
    my $str = shift;

    # In MySQL 5.1 (and probably erlier versions as well) status
    # variables are not unique when looking at the first 19
    # characters.
    #
    #   SELECT LEFT(variable_name, 19), COUNT(*) 
    #     FROM global_status
    #    GROUP BY LEFT(variable_name, 19)
    #   HAVING COUNT(*) > 1;
    #   
    #   +-------------------------+----------+
    #   | left(variable_name, 19) | count(*) |
    #   +-------------------------+----------+
    #   | INNODB_BUFFER_POOL_     |       12 |
    #   | INNODB_DATA_PENDING     |        3 |
    #   | INNODB_OS_LOG_PENDI     |        2 |
    #   | INNODB_ROW_LOCK_TIM     |        3 |
    #   +-------------------------+----------+
    #   4 rows in set (0.05 sec)
    #   
    #   SELECT LEFT(variable_name, 19), COUNT(*) 
    #     FROM global_variables
    #    GROUP BY LEFT(variable_name, 19)
    #   HAVING COUNT(*) > 1;
    #   
    #   Empty set (0.05 sec)
    #
    # Not a problem yet since we don't use any of the Innodb_ status
    # variables ...
    
    return substr($str, 0, 19);
}


#
# In 'SHOW ENGINE INNODB STATUS' some 64 bit integers are split in two
# and needs to be shifted together..
#
sub innodb_bigint {
    my ($x, $y) = @_;

    return Math::BigInt->new($x)->blsft(32) + $y;
}


#---------------------------------------------------------------------
#  P A R S E   'SHOW ENGINE INNODB STATUS'   O U T P U T
#---------------------------------------------------------------------


# A nice walk through
# http://www.mysqlperformanceblog.com/2006/07/17/show-innodb-status-walk-through/

# The parsing is split in one subrutine per section. Each subroutine
# should parse a block with the following structure
#
# BLOCK NAME
# ----------
# block body ...
# more lines ....
# ----------


sub parse_innodb_status {
    local $_ = shift;

    # Skip headig, 6 lines
    for my $foo (1...6) {
        m/\G.*\n/gc;
    }

    parse_semaphores();
    skip('LATEST FOREIGN KEY ERROR');
    skip('LATEST DETECTED DEADLOCK');
    parse_transactions();
    parse_file_io();
    parse_insert_buffer_and_adaptive_hash_index();
    parse_log();
    parse_buffer_pool_and_memory();
    parse_row_operations();
}


sub skip {
    #warn substr($_, pos(), 20);
    my $section = shift;
    m/\G$section\n-+\n/gc &&  do {
        for (;;) {
            return if m/\G-+\n/gc;
            m/\G.*\n/gc;
        }
    };
}


sub parse_semaphores {
    #warn substr($_, pos(), 10);
    m/\GSEMAPHORES\n-+\n/gc or die('Parse failed');
    for (;;) {
        return if m/\G-+\n/gc;
        m/\GMutex spin waits (\d+), rounds (\d+), OS waits (\d+)\n/gc && do {
            $data->{ib_spin_waits}  = $1;
            $data->{ib_spin_rounds} = $2;
            $data->{ib_os_waits}    = $3;
            next;
        };
        m/\G.*\n/gc;
    }
    
}


sub parse_transactions {
    #warn substr($_, pos(), 10);
    m/\GTRANSACTIONS\n-+\n/gc or die('Parse failed');
    for (;;) {
        return if m/\G-+\n/gc;
        m/\GTrx id counter (\d+) (\d+)\n/gc && do {
            $data->{ib_tnx} = innodb_bigint($1, $2);
            next;
        };
        m/\GPurge done for trx's n:o < (\d+) (\d+) undo n:o < (\d+) (\d+)\n/gc && do {
            $data->{ib_tnx_prg} = innodb_bigint($1, $2);
            next;
        };
        m/\GHistory list length (\d+)\n/gc && do {
            $data->{ib_tnx_hist} = $1;
            next;
        };
        m/\G.*\n/gc;
    }

}


sub parse_file_io {
    #warn substr($_, pos(), 10);
    m/\GFILE I\/O\n-+\n/gc or die('Parse failed');
    for (;;) {
        return if m/\G-+\n/gc;
        m/\GPending normal aio reads: (\d+), aio writes: (\d+),\n\s*ibuf aio reads: (\d+), log i\/o's: (\d+), sync i\/o's: (\d+)\n/gc && do {
            $data->{ib_iop_aioread}  = $1;
            $data->{ib_iop_aiowrite} = $2;
            $data->{ib_iop_ibuf_aio} = $3;
            $data->{ib_iop_log}      = $4;
            $data->{ib_iop_sync}     = $5;
            next;
        };
        m/\GPending flushes \(fsync\) log: (\d+); buffer pool: (\d+)\n/gc && do {
            $data->{ib_iop_flush_log}   = $1;
            $data->{ib_iop_flush_bpool} = $2;
            next;
        };
        m/\G(\d+) OS file reads, (\d+) OS file writes, (\d+) OS fsyncs\n/gc && do {
            $data->{ib_io_read}  = $1;
            $data->{ib_io_write} = $2;
            $data->{ib_io_fsync} = $3;
            next;
        };
        m/\G.*\n/gc;
    }
}


sub parse_insert_buffer_and_adaptive_hash_index {
    #warn substr($_, pos(), 10);
    m/\GINSERT BUFFER AND ADAPTIVE HASH INDEX\n-+\n/gc or die('Parse failed');
    for (;;) {
        return if m/\G-+\n/gc;
        m/\G(\d+) inserts, (\d+) merged recs, (\d+) merges\n/gc && do {
            $data->{ib_ibuf_inserts}    = $1;
            $data->{ib_ibuf_merged_rec} = $2;
            $data->{ib_ibuf_merges}     = $3;
            next;
        };
        m/\G.*\n/gc;
    }
}


sub parse_log {
    #warn substr($_, pos(), 10);
    m/\GLOG\n-+\n/gc or die('Parse failed');
    for (;;) {
        return if m/\G-+\n/gc;
        m/Log sequence number (\d+) (\d+)\n/gc && do {
            $data->{ib_log_written} = innodb_bigint($1, $2);
            next;
        };
        m/Log flushed up to\s+(\d+) (\d+)\n/gc && do {
            $data->{ib_log_flush} = innodb_bigint($1, $2);
            next;
        };
        m/\G(\d+) log i\/o's done.*\n/gc && do {
            $data->{ib_io_log} = $1;
            next;
        };
        m/\G.*\n/gc;
    }
}

sub parse_buffer_pool_and_memory {
    #warn substr($_, pos(), 10);
    m/\GBUFFER POOL AND MEMORY\n-+\n/gc or die('Parse failed');
    for (;;) {
        return if m/\G-+\n/gc;
        m/\GBuffer pool size\s+(\d+)\n/gc && do {
            $data->{ib_bpool_size} = $1;
            next;
        };
        m/\GFree buffers\s+(\d+)\n/gc && do {
            $data->{ib_bpool_free} = $1;
            next;
        };
        m/\GDatabase pages\s+(\d+)\n/gc && do {
            $data->{ib_bpool_dbpages} = $1;
            next;
        };
        m/\GModified db pages\s+(\d+)\n/gc && do {
            $data->{ib_bpool_modpages} = $1;
            next;
        };
        m/\GPages read (\d+), created (\d+), written (\d+)\n/gc && do {
            $data->{ib_bpool_read}    = $1;
            $data->{ib_bpool_created} = $2;
            $data->{ib_bpool_written} = $3;
            next;
        };
        m/\G.*\n/gc;
    }
}


sub parse_row_operations {
    #warn substr($_, pos(), 10);
    m/\GROW OPERATIONS\n-+\n/gc or die('Parse failed');
    for (;;) {
        return if m/\G-+\n/gc;
        m/\G.*\n/gc;
    }
}

main();


__END__

=head1 NAME

mysql_ - Munin plugin to display misc MySQL server status 

=head1 APPLICABLE SYSTEMS

Any MySQL platform, tested on MySQL 5.1.29 and 5.0.51

=head1 CONFIGURATION

This script is used to generate data for several graphs. To generate
data for one specific graph, you need to create a symbolic link with a
name like mysql_<GRAPH> to this script. 

To get a list of symlinks that can be created, run:

  ./mysql_ suggest

In addition you might need to specify connection parameters in the
plugin configuration to override the defaults. For example

  [mysql*]
  env.mysqlconnection DBI:mysql:mysql;host=127.0.0.1;port=3306
  env.mysqluser root
  env.mysqlpassword geheim
  env.mysqlcheck vars,innodb,master,slave

If you don't use InnoDB and the server is not an replication slave:

  env.mysqlcheck vars,master

This will prevent the plugin from issuing SHOW ENGINE INNODB STATUS
and SHOW SLAVE STATUS commands.

=head1 DEPENDENCIES

=over

=item Cache::Cache

The plugin uses shared memory to cache the statistics gathered from
MySQL. This ensures minimal inpact on the MySQL server.

=item DBD::Mysql

=back

=head1 INTERPRETATION

=head2 InnoDB

The statistics from innodb are mainly collected from the command 

  SHOW ENGINE INNODB STATUS

A nice walk through is found at http://www.mysqlperformanceblog.com/2006/07/17/show-innodb-status-walk-through/

=head2 The graphs

FIX point to relevant sections in the MySQL manual and other www
resources for each graph

=over

=item mysql_replication

slave_running and slave_stopped creates an alterning color under the
seconds_behind_master line. It will have the color of slave_running
when the SQL thread runs and the color of slave_stopped otherwise.

=back

=head1 AUTHOR

Kjell-Magne Øierud <kjellm@acm.org>

Inspired by the cacti graphs made by Xaprb
http://code.google.com/p/mysql-cacti-templates/ as viewed on
http://www.xaprb.com/blog/2008/05/25/screenshots-of-improved-mysql-cacti-templates/.

=head1 LICENSE

Copyright (C) 2008,2009 Kjell-Magne Øierud

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 2 dated June, 1991.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
USA.

=head1 VERSION

0.1.1

=head1 CHANGES

=over

=item 0.1.1

=over

=item Fixed bug in parsing of SHOW ENGINE INNODB STATUS

=item Removed dependency on Math::BigInt::GMP. Caused segfaults.

=item Changed drawing type LINE to LINE1 for better compability with
older versions of munin/rrdtool

=back

=cut

